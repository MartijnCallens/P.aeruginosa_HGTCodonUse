# Pan-genome analysis

## SiLiX homolog clustering

Requirements:
* NCBI-blast+ Nucleotide-Nucleotide BLAST 2.2.31+
* silix version 1.2.9

First, create a file named "all_CDS.ffn" containing the predicted CDS from all the strains

```bash
#BASH script to create a file containing all CDS

mkdir homolog_clustering/SiLiX -p

for dir in ./PROKKA/*/; do
    genomeName=$(echo $dir | cut -d '/' -f 3 | tr -d '/')
    cat ./PROKKA/$genomeName/$genomeName.ffn >> ./homolog_clustering/SiLiX/all_CDS.ffn
done

```

Perform an all-against-all blast

*note: if your computer does not have enough memory to run the blast in one go, you can create multiple blast databases (e.g. one for each strain) and run multiple blast commands.*

```bash
#BASH script for all-against-all blast

makeblastdb -in ./homolog_clustering/SiLiX/all_CDS.ffn -dbtype nucl -out ./homolog_clustering/SiLiX/blastdb/all_CDS_blastdb # Create a local blast database from the all_CDS.ffn file

blastn -db ./homolog_clustering/SiLiX/blastdb/all_CDS_blastdb -query ./homolog_clustering/SiLiX/all_CDS.ffn -outfmt 6 -out ./homolog_clustering/SiLiX/all-vs-all -num_threads 25

```

Run SiLiX clustering

Clustering parameters are set to: overlap = 0.7% (min. % overlap to accept blast hits for building families = 70%) and identity = 0.6 (min. % identity to accept blast hits for building families = 60%).

```bash
#BASH script to perform SiLiX clustering

silix ./homolog_clustering/SiLiX/all_CDS.ffn ./homolog_clustering/SiLiX/all-vs-all -r 0.7 -i 0.6 -f CLUSTER > ./homolog_clustering/SiLiX/silix_clusters

```
## Roary pan-genome analysis

```bash
#BASH script to run Roary

#Create a directory containing only the GFF files from the genome data

mkdir ./homolog_clustering/Roary/GFF_files -p

for directory in ./PROKKA/*; do
    cp $directory/*gff ./homolog_clustering/Roary/GFF_files
done

#Run the roary pipeline on the GFF files
roary -p 25 -f ./homolog_clustering/Roary/Roary_output ./homolog_clustering/Roary/GFF_files/*.gff
```

## Core gene clusters

Create the 'core_genome' directory

```bash

mkdir core_genome

```

### Extract core genes from SiLiX clusters

Create files listing the core genes predicted from SiLiX clustering. The example below shows how to do this for those gene families present in all strains. The 'size' varible can be changed to include those families present in less strains (down to 89) and a separate file can be created for each size class.

```r
# R-script to list core genes predicted from SiLiX clustering

library(plyr)

clusters <- read.csv2(file = "./homolog_clustering/SiLiX/silix_clusters", header = FALSE, sep = "\t", stringsAsFactors = FALSE) # Load the file with predicted clusters %identity = 0.6; %overlap = 0.7.
colnames(clusters) <- c("cluster", "sequence") # Rename the columns

# Get a list of all cluster sizes
clusterSizes <- count(clusters, vars = "cluster")

clusterList <- NULL
size <- 94 # set the size of clusters that need to be listed

for(i in clusterSizes[which(clusterSizes$freq == size),]$cluster){ #Iterate over the clusters with a defined size
  
  sequences <- clusters[clusters$cluster==i,]$sequence #Get sequence id's for this cluster
  
  check <- NULL
  for(n in strsplit(sequences, split = "_")){check <- c(check,(n[2]))} #Create a vector with genome id's  
  if(length(check) == length(unique(check))){ # Check for duplicate genome id's
     clusterList <- rbind(clusterList, (c(i, clusters[clusters$cluster==i,]$sequence))) #Append the cluster name and gene id's to clusterList
  }
}

write.table(clusterList, file = "./core_genome/silix_94", quote = FALSE, sep = ",", col.names = FALSE, row.names = FALSE)

```

### Extract core genes from Roary output

```bash


#Get a list of all the core genes
query_pan_genome -g ./homolog_clustering/Roary/Roary_output/clustered_proteins -o ./homolog_clustering/Roary/Roary_output/query_core_genes -a intersection ./homolog_clustering/Roary/GFF_files/*.gff

#Change the ":" delimiter for the first column into a tab
cat query_core_genes | tr ": " "\t" > query_core_genes_2

```

### Combine inferred core genes from SiLiX and Roary

```R
# Load the core cluster file generated by Roary:
RoaryCoreClusters <- read.csv2(file = "./homolog_clustering/Roary/Roary_output/query_core_genes_2", sep = "\t", header = FALSE, stringsAsFactors = FALSE, strip.white = TRUE)

RoaryCoreClusters <- as.matrix(RoaryCoreClusters)

# Check which Silix clusters of size = 94 have the same content as a Roary core cluster and write these to the file Silix_Roary_94
clusterList <- as.matrix(clusterList, stringsAsFactors = FALSE) #Make a Silix cluster list for size = 94 into a data frame

Silix_Roary_94 <- NULL
Roary_checked <- NULL # Make a vector to collect the names of all Roary clusters that are found in Silix clusters >= 94

for(i in 1:nrow(clusterList)){
  Silix_cluster <- clusterList[i, 2:95]
  for(ii in 1:nrow(RoaryCoreClusters)){
    Roary_cluster <- RoaryCoreClusters[ii, 2:95]
    if(setequal(Silix_cluster, Roary_cluster)){
      Silix_Roary_94 <- rbind(Silix_Roary_94, clusterList[i,])
      Roary_checked <- c(Roary_checked, RoaryCoreClusters[ii,1])
    }
  }
}

write.table(Silix_Roary_94, file = "./core_genome/silix_roary_94", quote = FALSE, sep = ",", col.names = FALSE, row.names = FALSE)

#Check which Silix clusters of size > 94 contain a full roary core cluster and write these to the file Roary_in_large_Silix
Roary_in_large_Silix <- NULL

clustersLarge <- clusterSizes[which(clusterSizes$freq > 94),]$cluster

for(i in clustersLarge){
  Silix_cluster <- clusters[which(clusters$cluster==i),]$sequence
  for(ii in 1:nrow(RoaryCoreClusters)){
    Roary_cluster <- RoaryCoreClusters[ii, 2:95]
    if(!FALSE %in% (Roary_cluster %in% Silix_cluster)){
      Roary_in_large_Silix <- rbind(Roary_in_large_Silix, RoaryCoreClusters[ii,])
      Roary_checked <- c(Roary_checked, RoaryCoreClusters[ii,1])
    }
  }
}

write.table(Roary_in_large_Silix, file = "./core_genome/Roary_in_large_Silix", quote = FALSE, sep = ",", col.names = FALSE, row.names = FALSE)

# Now use the Roary_checked vector to filter out core gene clusters that were not found with Silix
Roary_extra <- RoaryCoreClusters[which(!(RoaryCoreClusters[,1] %in% Roary_checked)),]

write.table(Roary_extra, file = "./core_genome/Roary_extra", quote = FALSE, sep = ",", col.names = FALSE, row.names = FALSE)

```

Create a file containing all the inferred core gene clusters

```bash

cat silix_94 silix_93 silix_92 silix_91 silix_91 silix_90 silix_89 Roary_in_large_Silix Roary_extra > all_core_genes

```

### Create a FASTA file for each core gene cluster

Write a FASTA file containing the sequences for each orthologous core gene cluster

```python
#Python script to obtain core gene clusters inferred by SiLiX and Roary (one file for each core gene cluster)
import os
from Bio import SeqIO

queryCoreFile = "./core_genome/all_core_genes" #Path to core genome clusters file
allCDSFile = "./homolog_clustering/SiLiX/all_CDS.ffn" #Path to file containing all CDS for all genomes

coreClusters = open(queryCoreFile, 'rU') 
allCDS = SeqIO.parse(allCDSFile, "fasta")

allCDS_dict = SeqIO.to_dict(allCDS) #Make a searchable dictionary of all CDS

for line in coreClusters:

	records = []	
	data = line.rstrip().split(',') #Split line from coreClusters into clustername and locus IDs
	clusterName = data[0] #Get the name of the cluster
	fileName = clusterName + ".ffn"

	seqIDs = data[1:] #Make a list of all locus IDs within the cluster
	 
	for ID in seqIDs: #iterate over the locus IDs within the cluster
		if ID.startswith("GCF"): #Only include correct sequence IDs
		
			records.append(allCDS_dict[ID]) #Search sequence record of ID in the dictionary
		
	SeqIO.write(records, fileName, "fasta") #Write a file containing sequence record with clustername in the filename

```

## Accessory gene clusters

### Unique genes

Unique genes are accessory genes that occur in only a single strain, these will be processed separately from 'flexible' genes that are found in more than one strain (but are not core genes).

```bash
mkdir Accessory_genes/Unique_genes -p
```

Extract all the gene ID's in clusters that contain only a single gene

```R
# Create a file SiLiX_unique, containing all the gene IDs for genes that did not cluster with other genes
for(i in clusterSizes[which(clusterSizes$freq == 1),]$cluster){ #Iterate over the clusters of size = 1
  write(clusters[clusters$cluster==i,]$sequence, file = "./Accessory_genes/Unique_genes/SiLiX_unique", append = TRUE, sep = "\n")
}
```

Create a FASTA file for each unique gene cluster

```python
#Python script to obtain sequences for unique genes predicted by SiLix
import os
from Bio import SeqIO

queryFile = "./Accessory_genes/Unique_genes/SiLiX_unique" #Path to file containing unique gene names
allCDSFile = "./homolog_clustering/SiLiX/all_CDS.ffn" #Path to file containing all CDS for all genomes

seqs = open(queryFile, 'rU')
allCDS = SeqIO.parse(allCDSFile, "fasta")
records = []

allCDS_dict = SeqIO.to_dict(allCDS) #Make a searchable dictionary of all CDS

for ID in seqs: #Iterate over the locus IDs within the cluster
  #seqID = line.rstip()
	records.append(allCDS_dict[ID.rstrip()]) #Search sequence record of ID in the dictionary
		
SeqIO.write(records, "./Accessory_genes/Unique_genes/SiLiX_unique.ffn", "fasta") #Write a file containing sequence record with clustername in the filename

```

### Flexible genes

Flexible genes are accessory genes that are found in more than one strain, but are not core genes (that in this case occur in 89 or more strains). Within the flexible genes, three categories can be discerned:

* Flexible: each gene in a flexible gene cluster is found in a separate strain
* Flexible duplications: genes within the flexible gene cluster are found two or more times in at least one strain.
* Flexible unique: genes within flexible gene cluster are only found in a single strain (with multiple copies).

```bash
mkdir Accessory_genes/Flexible_genes -p
```

```R
# For all clusters of size 1 < n < 89, create three files, SiLiX_flexible (each gene in a separate strain), SiLiX_flexible_duplications (genes duplicated in some strains) and SiLiX_flexible_unique (genes only occur in a single strain)

for(i in clusterSizes[which(clusterSizes$freq > 1 & clusterSizes$freq < 89),]$cluster){ #Iterate over the clusters with a defined size
  
  sequences <- clusters[clusters$cluster==i,]$sequence #Get sequence id's for this cluster
  
  check <- NULL
  for(n in strsplit(sequences, split = "_")){check <- c(check,(n[2]))} #Create a vector with genome id's
  
  if(length(check) == length(unique(check))){ # Check for cases SiLiX_flexible
     cluster <- paste(c(i, sequences), collapse = ",")
     write(cluster, file = "./Accessory_genes/Flexible_genes/SiLiX_flexible", append = TRUE)
  }
  else if(length(unique(check))==1){ # Check for cases SiLiX_flexible_unique
    cluster <- paste(c(i, sequences), collapse = ",")
     write(cluster, file = "./Accessory_genes/Flexible_genes/SiLiX_flexible_unique", append = TRUE)
  }
  else if(length(check) != length(unique(check))){ # Check for cases SiLiX_flexible_duplications
    cluster <- paste(c(i, sequences), collapse = ",")
     write(cluster, file = "./Accessory_genes/Flexible_genes/SiLiX_flexible_duplications", append = TRUE)
  }
}

```

Create a FASTA file for each flexible gene cluster.

Run this script for the 'SiLiX_flexible', 'SiLiX_flexible_unique' and 'SiLiX_flexible_duplications' files.

```python
#Script to obtain flexible gene clusters obtained by SiLiX (one file for each flexible gene cluster)
import os
from Bio import SeqIO

queryFile = "./Accessory_genes/Flexible_genes/SiLiX_flexible" #Path to file containing flexible gene clusters
allCDSFile = "./homolog_clustering/SiLiX/all_CDS.ffn" #Path to file containing all CDS for all genomes

clusters = open(queryFile, 'rU') 
allCDS = SeqIO.parse(allCDSFile, "fasta")

allCDS_dict = SeqIO.to_dict(allCDS) #Make a searchable dictionary of all CDS

for line in clusters:

	records = []	
	data = line.rstrip().split(',') #Split line from into clustername and locus IDs
	clusterName = data[0] #Get the name of the cluster
	fileName = "./Accessory_genes/Flexible_genes/" + clusterName + ".ffn" 

	seqIDs = data[1:] #Make a list of all locus IDs within the cluster
	 
	for ID in seqIDs: #Iterate over the locus IDs within the cluster
		if ID.startswith("GCF"): #Only include correct sequence IDs
		
			records.append(allCDS_dict[ID]) #Search sequence record of ID in the dictionary
		
	SeqIO.write(records, fileName, "fasta") #Write a file containing sequence record with clustername in the filename
	
```

